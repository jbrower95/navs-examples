// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "navs/src/ITaskDispatch.sol";
import "navs/src/IBaseNavsReceiver.sol";

/**
 * Abstract NavsReceiver contract that implements IBaseNavsReceiver
 * 
 * This contract combines service functions and callback handling in one abstract contract.
 * Users should extend this contract and override the abstract callback methods they need.
 * This contract automatically handles onNavsResult and onNavsError routing from TaskDispatch.
 * 
 * Generated by navs-gen on 2025-06-09T16:35:36.303Z
 * Total functions: 1
 */
abstract contract NavsReceiver is IBaseNavsReceiver {

    // Package information constants
    string public constant PACKAGE_NAME = "navs-aml";
    string public constant PACKAGE_VERSION = "1.0.0";


    /**
     * Get TaskDispatch contract address for current chain
     * @return address TaskDispatch contract address (address(0) if not deployed on this chain)
     */
    function getTaskDispatchAddress() internal view virtual returns (address) {
        uint256 chainId = block.chainid;
        if (chainId == 84532) return 0x6f9cfE33a376124237576D36B2bad4F56C875DB1; // Base Sepolia
        return address(0); // TaskDispatch not deployed on this chain
    }

    /**
     * Modifier to ensure only TaskDispatch can call callback functions
     */
    modifier onlyTaskDispatch() {
        address taskDispatchAddr = getTaskDispatchAddress();
        require(msg.sender == taskDispatchAddr, "Only TaskDispatch can call this function");
        _;
    }

    /**
     * Implementation of IBaseNavsReceiver.onNavsResult
     * Automatically routes to typed callback methods
     * Can only be called by TaskDispatch contract
     */
    function onNavsResult(uint256 taskId, string memory functionName, bytes memory result) external override onlyTaskDispatch {
        _handleNavsCallback(taskId, functionName, result, "");
    }
    
    /**
     * Implementation of IBaseNavsReceiver.onNavsError  
     * Automatically routes to typed callback methods with error message
     * Can only be called by TaskDispatch contract
     */
    function onNavsError(uint256 taskId, string memory functionName, string memory error) external override onlyTaskDispatch {
        _handleNavsErrorCallback(taskId, functionName, error);
    }

    /**
     * Internal callback router for type-safe callbacks
     */
    function _handleNavsCallback(
        uint256 taskId, 
        string memory functionName, 
        bytes memory result,
        string memory error
    ) internal {
        if (keccak256(bytes(functionName)) == keccak256(bytes("isAddressSanctioned"))) {
            // Decode the enhanced callback data from TaskDispatch
            (bytes memory originalArgs, bytes memory packedResult) = abi.decode(result, (bytes, bytes));
            
            // Decode the packed result from navs-core
            (string memory resultType, bytes memory resultBytes, bytes32 l1calldatahash) = abi.decode(packedResult, (string, bytes, bytes32));
            
            // Decode the original parameters
            (address param0) = abi.decode(originalArgs, (address));
            
            // Decode the function result
            bool resultValue = abi.decode(resultBytes, (bool));
            
            onIsAddressSanctioned(taskId, param0, resultValue, error);
            return;
        }

        revert("Unknown function");
    }
    
    /**
     * Internal error callback router for type-safe error callbacks
     */
    function _handleNavsErrorCallback(
        uint256 taskId, 
        string memory functionName, 
        string memory error
    ) internal {
        if (keccak256(bytes(functionName)) == keccak256(bytes("isAddressSanctioned"))) {
            onIsAddressSanctioned(taskId, address(0), false, error);
            return;
        }

        revert("Unknown function");
    }

    // ================== SERVICE FUNCTIONS ==================

    /**
     * Call isAddressSanctioned with callback
     * Function isAddressSanctioned from index.ts
     * The calling contract (address(this)) will receive the callback.
     * @param address_param Parameter of type address
     * @param requiredStakeWei Minimum stake threshold for execution in wei
     * @return taskId Unique identifier for tracking this task
     */
    function isAddressSanctioned(address address_param, uint256 requiredStakeWei) internal returns (uint256 taskId) {
        bytes memory encodedParams = abi.encode(address_param);
        
        return _submitTaskWithCallback(
            "isAddressSanctioned", 
            encodedParams, 
            address(this),
            requiredStakeWei,
            ITaskDispatch.ConsensusType.EXACT_MATCH,
            false
        );
    }

    
    /**
     * Internal function to handle asynchronous task submission with callback
     * @param functionName The name of the function to execute
     * @param encodedParams ABI-encoded parameters
     * @param callbackReceiver Address that will receive the callback
     * @param requiredStake Minimum stake threshold for execution
     * @param consensusType Type of consensus to use for the task
     * @param isLocal Whether this is a local task
     * @return taskId Unique identifier for tracking this task
     */
    function _submitTaskWithCallback(
        string memory functionName, 
        bytes memory encodedParams,
        address callbackReceiver,
        uint256 requiredStake,
        ITaskDispatch.ConsensusType consensusType,
        bool isLocal
    ) internal returns (uint256) {
        // Call TaskDispatch with callback receiver
        address taskDispatchAddr = getTaskDispatchAddress();
        require(taskDispatchAddr != address(0), "TaskDispatch address not set for this chain");
        
        uint256 taskId = ITaskDispatch(taskDispatchAddr).submitTask(
            "navs-aml", // Service name from package.json
            "1.0.0", // Service version from package.json
            functionName,
            encodedParams,
            requiredStake, // Use the provided stake threshold
            consensusType, // Use the determined consensus type
            false, // isConsensus
            callbackReceiver, // Callback will be executed automatically by TaskDispatch
            isLocal, // Whether this is a local task
            true // isDeterministic - auto-mark generated tasks as deterministic
        );
        
        return taskId;
    }
    // ================== ABSTRACT CALLBACK METHODS ==================

    /**
     * Abstract callback for isAddressSanctioned function completion
     * Override this function in your contract to handle isAddressSanctioned results
     * @param taskId The unique identifier for the completed task
     * @param address_param Original parameter of type address
     * @param result The result returned by isAddressSanctioned
     * @param error Error message if the function failed, empty string if successful
     */
    function onIsAddressSanctioned(uint256 taskId, address address_param, bool result, string memory error) internal virtual;
}
