// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "navs/src/IBaseNavsReceiver.sol";
import "./INavsCallbacks.sol";
import "./service.sol";

/**
 * Abstract NavsReceiver contract that implements IBaseNavsReceiver and INavsCallbacks
 * 
 * Users should extend this contract and override the callback methods they need.
 * This contract automatically handles onNavsResult and onNavsError routing.
 * 
 * Generated by navs-gen on 2025-06-02T22:13:29.034Z
 */
abstract contract NavsReceiver is IBaseNavsReceiver, INavsCallbacks {
    
    using NavsAml for *;

    // Package information constants
    string public constant PACKAGE_NAME = "navs-aml";
    string public constant PACKAGE_VERSION = "1.0.0";

    /**
     * Implementation of IBaseNavsReceiver.onNavsResult
     * Automatically routes to typed callback methods
     */
    function onNavsResult(bytes32 taskId, string memory functionName, bytes memory result) external override {
        _handleNavsCallback(taskId, functionName, result, "");
    }
    
    /**
     * Implementation of IBaseNavsReceiver.onNavsError  
     * Automatically routes to typed callback methods with error message
     */
    function onNavsError(bytes32 taskId, string memory functionName, string memory error) external override {
        _handleNavsErrorCallback(taskId, functionName, error);
    }

    /**
     * Internal callback router for type-safe callbacks
     */
    function _handleNavsCallback(
        bytes32 taskId, 
        string memory functionName, 
        bytes memory result,
        string memory error
    ) internal {
        if (keccak256(bytes(functionName)) == keccak256(bytes("isAddressSanctioned"))) {
            // Decode the enhanced callback data from TaskDispatch
            (bytes memory originalArgs, bytes memory packedResult) = abi.decode(result, (bytes, bytes));
            
            // Decode the packed result from navs-core
            (string memory resultType, bytes memory resultBytes, bytes memory l1calldatahash, bytes memory signedL1Calldata) = abi.decode(packedResult, (string, bytes, bytes, bytes));
            
            // Decode the original parameters
            (address param0) = abi.decode(originalArgs, (address));
            
            // Decode the function result
            bool resultValue = abi.decode(resultBytes, (bool));
            
            _onIsAddressSanctioned(taskId, param0, resultValue, error);
            return;
        }

        revert("Unknown function");
    }
    
    /**
     * Internal error callback router for type-safe error callbacks
     */
    function _handleNavsErrorCallback(
        bytes32 taskId, 
        string memory functionName, 
        string memory error
    ) internal {
        if (keccak256(bytes(functionName)) == keccak256(bytes("isAddressSanctioned"))) {
            _onIsAddressSanctioned(taskId, address(0), false, error);
            return;
        }

        revert("Unknown function");
    }

    // External callback methods (implementing INavsCallbacks)

    /**
     * External callback for isAddressSanctioned function completion (implements INavsCallbacks)
     * This calls the internal virtual method that you should override
     */
    function onIsAddressSanctioned(bytes32 taskId, address address_param, bool result, string memory error) external override {
        _onIsAddressSanctioned(taskId, address_param, result, error);
    }


    // Internal virtual callback methods - override these in your contract

    /**
     * Internal virtual callback for isAddressSanctioned function completion
     * Override this function in your contract to handle isAddressSanctioned results
     * @param taskId The unique identifier for the completed task
     * @param address_param Original parameter of type address
     * @param result The result returned by isAddressSanctioned
     * @param error Error message if the function failed, empty string if successful
     */
    function _onIsAddressSanctioned(bytes32 taskId, address address_param, bool result, string memory error) internal virtual {
        // Override this function in your contract
    }

}
